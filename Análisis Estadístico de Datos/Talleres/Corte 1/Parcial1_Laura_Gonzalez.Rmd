---
title: "Parcial 1"
author: "Laura Valentina Gonzalez Rodriguez"
date: "2023-03-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Se cargan algunas librerias
packages = c("dslabs", "MASS", "scatterplot3d", "car", "dplyr", "kableExtra", "plotrix")
## Se cargan o se instalan y cargan
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

```

## Primer Punto

### Un investigador cree que la media de las variables medidas es 30 en todas ellas. Realice una prueba de hipótesis para comprobar si esa afirmación es cierta.

Primero se cargaran las variables de interes: longitud del pico (bill length), la profundidad del pico (bill depth) y la logintud de la aleta ( fipper length) para realizar el $T^2$ respecto a H0 = [30,30,30].


```{r}
pengu = penguins2;
data_objetivo = subset(pengu, select = c("bill_length_mm", "bill_depth_mm", "flipper_length_mm" ));data_objetivo

h0 = c(30,30,30);
```

Para eso, se define el codigo en R que realiza la distribución T^2 y la comparativa con la multiplicación de Fisher.

```{r}

T2 = function (X, mu_0) { # Esto es la T^2
  x_bar = colMeans(X);
  S = cov(X);
  
  n = nrow(X);
  return(n * t(x_bar - mu_0) %*% solve(S) %*% (x_bar - mu_0));
}

F_val = function (X, mu_0, alpha = 0.05) { # Esto es fisher
  p = length(mu_0);
  n = nrow(X)
  
  df_num = p;
  df_denom = n - p;
  
  return(qf(1 - alpha, df_num, df_denom));
}

F_val_lone = function (X, alpha = 0.05) { # Esto es fisher
  p = ncol(X);
  n = nrow(X)
  
  df_num = p;
  df_denom = n - p;
  
  return(qf(1 - alpha, df_num, df_denom));
}


T2_F = function(X, mu_0, alpha = 0.05) { # Una vaiana rara que utiliza fisher y maso la T^2
  p = length(mu_0);
  n = nrow(X);
  
  df_num = (n - 1) * p;
  df_denom = n - p;
  return(df_num / df_denom * F_val(X, mu_0, alpha));
}


T2_test = function(X, mu_0, alpha = 0.05) { # T2 debe ser menor que T2_F para aceptar
  return(T2(X, mu_0) < T2_F(X, mu_0, alpha)); # Si retorna true, se acepta mu_0. 
}



```

Se reemplazan los valores en la función anterior obteniendo que:

```{r}

Valor_t2 = T2(data_objetivo,h0); Valor_t2

Valor_fish = T2_F(data_objetivo,h0); Valor_fish

T2_test(data_objetivo,h0)

```
Particularmente para este caso, se tiene que $T^2=68512.99 > 7.94378 = 3.0181F_{3,300}(0.05)$. Por lo cuál, se rechaza la hipotesis de que la media cada una de las variables es 30 ($H_0 : \mu \neq [30,30,30]$) con un nivel de 5% de significancia.

## Segundo Punto

### En la muestra, ¿cuál es la especie que tiene más alta cada una de las mediciones?

Las mediciones anteriores (longitud del pico (bill length), la profundidad del pico (bill depth) y la logintud de la aleta ( fipper length)), se deben agrupar particularmene por la especie, correspondiente a species(1,2,3)

```{r}
data_especies = subset(pengu, select = c("species","bill_length_mm", "bill_depth_mm", "flipper_length_mm" ));
datos_especies <- split(data_especies, data_especies$species); datos_especies
```
Con lo cuál, podemos generar una tabla comparativa para cada subconjunto. 

Para la especie 1, Adelie se tiene:

```{r}
grupo_1 <- datos_especies[[1]][,-which(names(datos_especies[[i]]) == "species")];

sapply(grupo_1, function(x) {
  data.frame(
  mean = round(mean(x), digits = 3),
  median = median(x),
  mode = names(which.max(table(x))),
  sd = round(sd(x), digits = 3)
  )
}) %>%  kable() %>% kable_styling(latex_options = "hold_position")

```

Para la especie 2, Gentoo se tiene:

```{r}
grupo_2 <- datos_especies[[2]][,-which(names(datos_especies[[i]]) == "species")];

sapply(grupo_2, function(x) {
  data.frame(
  mean = round(mean(x), digits = 3),
  median = median(x),
  mode = names(which.max(table(x))),
  sd = round(sd(x), digits = 3)
  )
}) %>%  kable() %>% kable_styling(latex_options = "hold_position")

```


Para la especie 3, Chinstrap se tiene:

```{r}
grupo_3 <- datos_especies[[3]][,-which(names(datos_especies[[i]]) == "species")];

sapply(grupo_3, function(x) {
  data.frame(
  mean = round(mean(x), digits = 3),
  median = median(x),
  mode = names(which.max(table(x))),
  sd = round(sd(x), digits = 3)
  )
}) %>%  kable() %>% kable_styling(latex_options = "hold_position")

```

Para la medición de bill_length_mm, la media de la especie 3 (Chinstrap) fue la mayor con un valor de 48.834 mm. Para la medición de bill_depth_mm, la media de la especie especie 3 (Chinstrap) fue ligeramente la mayor con un valor de 18.421 mm en compración a la especie 1 (Adelie) con 18.347 mm. Finalmente para flipper_length_mm la media de la especie 2 (Gentoo) fue la mayor con un valor de 217.235 mm.


## Tercer Punto

### En la muestra, ¿cuál es la isla en la que es más alta cada una de las mediciones?

Las mediciones anteriores (longitud del pico (bill length), la profundidad del pico (bill depth) y la logintud de la aleta ( fipper length)), se deben agrupar particularmene por la especie, correspondiente a island(1,2,3)


```{r}

data_isla = subset(pengu, select = c("island","bill_length_mm", "bill_depth_mm", "flipper_length_mm" ));
datos_isla <- split(data_isla, data_isla$island); datos_isla

```

Con lo cuál, podemos generar una tabla comparativa para cada subconjunto. 

Para la isla 1, Torgesen, se tiene:

```{r}
grup_1 <- datos_isla[[1]][,-which(names(datos_isla[[i]]) == "island")];

sapply(grup_1, function(x) {
  data.frame(
  mean = round(mean(x), digits = 3),
  median = median(x),
  mode = names(which.max(table(x))),
  sd = round(sd(x), digits = 3)
  )
}) %>%  kable() %>% kable_styling(latex_options = "hold_position")

```

Para la isla 2, Biscoe, se tiene:

```{r}
grup_2 <- datos_isla[[2]][,-which(names(datos_isla[[i]]) == "island")];

sapply(grup_2, function(x) {
  data.frame(
  mean = round(mean(x), digits = 3),
  median = median(x),
  mode = names(which.max(table(x))),
  sd = round(sd(x), digits = 3)
  )
}) %>%  kable() %>% kable_styling(latex_options = "hold_position")

```

Para la isla 3, Dream, se tiene:

```{r}
grup_3 <- datos_isla[[3]][,-which(names(datos_isla[[i]]) == "island")];

sapply(grup_3, function(x) {
  data.frame(
  mean = round(mean(x), digits = 3),
  median = median(x),
  mode = names(which.max(table(x))),
  sd = round(sd(x), digits = 3)
  )
}) %>%  kable() %>% kable_styling(latex_options = "hold_position")

```

Para la medición de bill_length_mm, la media de la isla 1 (Torgesen) fue la mayor con un valor de 45.248 mm. Para la medición de bill_depth_mm, la media de la isla 3 (Dream) fue ligeramente la mayor con un valor de 18.451 mm. Finalmente para flipper_length_mm la media de la isla 1 (Torgesen) fue la mayor con un valor de 209.558 mm.

## Cuarto Punto

### Encuentre y grafique la elipse de confianza para la longitud y la profundidad del pico de la especie Adelie en la isla Biscoe. ¿Cuál es el centro de la elipse?

Primero se debe obtener el dataset de dos columnas (bill length y bill depth) filtrado a la especie 1 (Adelie) y la isla 2 (Biscoe).

```{r}

data_elipse = subset(pengu, select = c("species","island", "bill_length_mm", "bill_depth_mm"));
datos_elipse <- split(data_elipse, data_elipse$species); 
grupo_especie <- datos_elipse[[1]][,-which(names(datos_especies[[i]]) == "species")];
data_espe <- split(grupo_especie, grupo_especie$island);

isla_especie <- data_espe[[2]][,-which(names(data_espe[[i]]) == "island")];isla_especie


```

Con la data seleccionada, se encuentran los ejes de confianza:

```{r}

sqrt_axes <-function(Z,i){
  p = ncol(Z);
  n = nrow(Z);
  einz = eigen(cov(Z));
  return(sqrt(einz$values[i])*sqrt(((p*(n-1))/(n*(n-p)))*F_val(Z,h0)))
}

major_axes <- function(Z){
  p = ncol(Z);
  n = nrow(Z);
  Z_bar = colMeans(Z); 
  einz = eigen(cov(Z));
  z1 = Z_bar + sqrt_axes(Z,1) *einz$vectors[1];
  z2 =  Z_bar - sqrt_axes(Z,1)*einz$vectors[1];
  print("Ejes Mayores")
  return(c(z1,z2));
}

minor_axes <- function(Z){
  p = ncol(Z);
  n = nrow(Z);
  Z_bar = colMeans(Z); 
  einz = eigen(cov(Z));
  z1 = Z_bar + sqrt_axes(Z,2)*einz$vectors[2];
  z2 =  Z_bar - sqrt_axes(Z,2)*einz$vectors[2];
  print("Ejes Menores")
  return(c(z1,z2));
}

major_axes(isla_especie)
minor_axes(isla_especie)
```
Y apartir de los ejes, la longitud del mayor y menor

```{r}
long_axes <-function(X){
  einz = eigen(cov(X));
  n = nrow(X);
  l1 = sqrt(einz$values[1])*sqrt((1/n)*F_val_lone(X));
  l2 = sqrt(einz$values[2])*sqrt((1/n)*F_val_lone(X));
  return(c(l1,l2))
}
long_axes(isla_especie)
```

Adicionalmente sabemos que el promedio de las variables, será el cetro de la elipse. 

```{r}
colMeans(isla_especie)
```

Finalmente, se realiza la gráfica, de centro en azul:

```{r}
make_hip <- function(Z){
  p = ncol(Z);
  n = nrow(Z);
  angle = atan(eigen(cov(Z))$vectors[2,1]/eigen(cov(Z))$vectors[1,1])
  plot(0,pch='',ylab='bill_depth_mm',xlab='bill_length_mm',xlim=c(36,40),ylim=c(16,20))
  draw.ellipse(x=colMeans(Z)[1],y=colMeans(Z)[2],a=sqrt_axes(Z,1),b=sqrt_axes(Z,2),angle=angle,deg=FALSE)
  points(colMeans(Z)[1], colMeans(Z)[2], col = "blue", pch = 16)
}

make_hip(isla_especie)

```

## Quinto Punto

###  Si se afirma que, en la isla Biscoe, la especie Adelie tiene 40cm y 23cm como medias de la longitud y la profundidad del pico respectivamente, ¿ese punto está dentro de la región de confianza encontrada en el punto anterior? ¿Qué puede concluir de esto?

El punto rojo será las medias de la especie Adelie (40,23), generando la gráfica:

```{r}

make_hip_dot <- function(Z,d){
  p = ncol(Z);
  n = nrow(Z);
  angle = atan(eigen(cov(Z))$vectors[2,1]/eigen(cov(Z))$vectors[1,1])
  plot(0,pch='',ylab='bill_depth_mm',xlab='bill_length_mm',xlim=c(36,41),ylim=c(16,24))
  draw.ellipse(x=colMeans(Z)[1],y=colMeans(Z)[2],a=sqrt_axes(Z,1),b=sqrt_axes(Z,2),angle=angle,deg=FALSE)
  points(d[1], d[2], col = "red", pch = 16)
  points(colMeans(Z)[1], colMeans(Z)[2], col = "blue", pch = 16)
}

make_hip_dot(isla_especie, c(40,23))

```

Podemos observar graficamente que para la especie Adelie con medias (40,23) de longitud y profundidad, está afuera de la región de confianza encontrada anteriormente. Esto implica que la probabilidad de que la especie Adelie tenga de medidas 40 de longitud y 23 de profundidad es muy baja, suponiendo que los datos siguen esta distribución. En pocas palabras, es un punto atípico. 