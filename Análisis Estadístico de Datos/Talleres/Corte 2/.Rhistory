get_T2_intervals = function(a, n1, n2, p, x_bar1, x_bar2, S1, S2, alpha) {
C = sqrt(get_C2(n1, n2, p, alpha))
left = t(a) %*% (x_bar1 - x_bar2)
right = C * sqrt(t(a) %*% ((1/n1 + 1/n2) * spooled(n1, n2, S1, S2)) %*% a)
return(matrix(c(left + right, left - right)))
}
A = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2);
alpha = 0.01
T2_intervals = matrix(0, nrow = 2, ncol = 2)
for (i in 1:nrow(A)) {
a = A[i, ]
T2_intervals[, i] = get_T2_intervals(a, n1, n2, p, x_bar1, x_bar2, S1, S2, alpha)
}
T2_intervals
z1 = matrix(c(10, 5, 7, 19, 11, 18));
z2 = matrix(c(2, 3, 3, 6, 7, 9));
y = matrix(c(15, 9, 3, 25, 7, 13));
### DATOS DE PRUEBA. Ejemplo 7.4 del libro
z1 <- matrix(c(15.31, 15.20, 16.25, 14.33, 14.57, 17.33, 14.48, 14.91, 15.25, 13.89, 15.18, 14.44, 14.87, 18.63, 15.20, 25.76, 19.05, 15.37, 18.06, 16.35))
z2 <- matrix(c(57.3, 63.8, 65.4, 57.0, 63.8, 63.2, 60.2, 57.7, 56.4, 55.6, 62.6, 63.4, 60.2, 67.2, 57.1, 89.6, 68.6, 60.1, 66.3, 65.8))
y <- matrix(c(74.8, 74.0, 72.9, 70.0, 74.9, 76.0, 72.0, 73.5, 74.5, 73.5, 71.5, 71.0, 78.9, 86.5, 68.0, 102.0, 84.0, 69.0, 88.0, 76.0))
### PUNTO A
data = data.frame(z1, z2, y)
model = lm(y ~ z1 + z2, data = data)
coefs = coef(model)
beta0 = coefs[1]
beta1 = coefs[2]
beta2 = coefs[3]
epsilon = resid(model)
### PUNTO B
alpha = 0.05
si_beta1 = confint(model, level = 1 - alpha, parm=c(2))
si_beta2 = confint(model, level = 1 - alpha, parm=c(3))
### PUNTO C
beta1_index = 2
p_value = summary(model)$coefficients[beta1_index, 4]
alpha = 0.05
p_value > alpha # Si es FALSE, se puede rechazar H0 (que beta1 es 0)
### PUNTO D
newdata = data.frame(z1 = 6, z2 = 4);
expected_value2=30.96657+(2.63440*6)+(0.04518*4);
expected_value2
intervals = predict(model, newdata, interval = "confidence", level = 0.95)[2:3];
intervals
### PUNTO E
pred_intervals = predict(model, newdata, interval = "prediction", level = 0.95)[2:3]
pred_intervals
summary(model)
### PUNTO A
model = lm(medv ~ lstat, data = Boston)
summary(model)
print("La pendiente es -0.95 aproximadamente")
### PUNTO B
confint(model, level = 0.95)
### PUNTO C
newdata = data.frame(lstat = c(5, 10, 15))
newdata$medv = predict(model, newdata)
newmodel = lm(medv ~ lstat, data = newdata)
confint(newmodel, level = 0.95)
### PUNTO D
plot(medv ~ lstat, data = Boston)
abline(model)
### PUNTO E
model = lm(medv ~ ., data = Boston)
confint(model, level = 0.95)
### PUNTO F
newdata = colMeans(Boston[, names(Boston) != "medv"])
newdata = data.frame(as.list(newdata))
intervals = predict(model, newdata, interval = "confidence", level = 0.95); intervals
pred_intervals = predict(model, newdata, interval = "prediction", level = 0.95); pred_intervals
n1 = 5;
n2 = 3;
n3 = 4;
p = 2;
T1 = matrix(c(2, 3, 7, 2, 7, 9, 2, 5, 1, 5), ncol = p, nrow = n1);
T2 = matrix(c(3, 2, 9, 2, 4, 4), ncol = p, nrow = n2);
T3 = matrix(c(1, 7, 4, 3, 4, 2, 9, 2), ncol = p, nrow = n3);
data = data.frame(group=rep(c("T1", "T2", "T3"), times=c(n1,n2,n3)),
x1=c(T1[,1], T2[,1], T3[,1]),
x2=c(T1[,2], T2[,2], T3[,2]))
### PUNTO A
get_B = function(model) {
return(summary(model)$SS$group)
}
get_W = function(model) {
return(summary(model)$SS$Residuals)
}
model = manova(cbind(x1,x2) ~ group,data=data)
B = get_B(model);
W = get_W(model);
oneway_manova_table = B + W; oneway_manova_table
### PUNTO B
wilks = data.frame(as.list(summary(model, test="Wilks")$stats[1,]))$Wilks;
wilks
wilks_test = function(model, alpha) {
stats = data.frame(as.list(summary(model, test="Wilks")$stats[1,]));
num_df = stats$num.Df
den_df = stats$den.Df
approx_f = stats$approx.F
f = qf(1 - alpha, num_df, den_df)
return(approx_f > f) # Si es TRUE, se rechaza H0
}
alpha = 0.05
wilks_test(model, alpha)
### PUNTO C.
alpha = 0.05
g = 3
muestra = 100;
num_df = 2 * p;
den_df = 2 * (muestra - p - 2);
approx_f = (1 - sqrt(wilks)) / sqrt(wilks) * (muestra - g - 1) / (g - 1);
f = qf(1 - alpha, num_df, den_df);
print(approx_f)
print(f)
approx_f > f
spooled = function(n1, n2, S1, S2) {
return((n1 - 1) / (n1 + n2 - 2) * S1 + (n2 - 1) / (n1 + n2 - 2) * S2)
}
S_spool = spooled(n1, n2, S1, S2);S_spool
inv_S = solve((1 / n1 + 1 / n2) * spooled(n1, n2, S1, S2))
get_T2 = function(n1, n2, x_bar1, x_bar2, S1, S2) {
x_bar_diff = x_bar1 - x_bar2;
inv_S = solve((1 / n1 + 1 / n2) * spooled(n1, n2, S1, S2))
return(as.numeric(t(x_bar_diff) %*% inv_S %*% x_bar_diff))
}
get_C2 = function(n1, n2, p, alpha) {
return(((n1 + n2 - 2) * p / (n1 + n2 - p - 1) ) * qf(1 - alpha, p, n1 + n2 - p - 1))
}
get_T2(n1, n2, x_bar1, x_bar2, S1, S2)
alpha = 0.01
get_C2(n1, n2, p, alpha);
test_T2 = function(n1, n2, p, x_bar1, x_bar2, S1, S2, alpha) {
return(get_T2(n1, n2, x_bar1, x_bar2, S1, S2) > get_C2(n1, n2, p, alpha)) # Si es TRUE, se rechaza H0
}
test_T2(n1, n2, p, x_bar1, x_bar2, S1, S2, alpha)
get_T2_intervals = function(a, n1, n2, p, x_bar1, x_bar2, S1, S2, alpha) {
C = sqrt(get_C2(n1, n2, p, alpha))
left = t(a) %*% (x_bar1 - x_bar2)
right = C * sqrt(t(a) %*% ((1/n1 + 1/n2) * spooled(n1, n2, S1, S2)) %*% a)
return(matrix(c(left + right, left - right)))
}
A = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2);
alpha = 0.01
T2_intervals = matrix(0, nrow = 2, ncol = 2)
for (i in 1:nrow(A)) {
a = A[i, ]
T2_intervals[, i] = get_T2_intervals(a, n1, n2, p, x_bar1, x_bar2, S1, S2, alpha)
}
T2_intervals
epsilon = resid(model)
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
n1 = 3;
n2 = 4;
p = 2;
T2 = matrix(c(3, 1, 2, 3, 6, 3), nrow = n1, ncol =p);
T3 = matrix(c(2, 5, 3, 2, 3, 1, 1, 3), nrow=n2, ncol=p);
x_bar1 = colMeans(T2);
x_bar2 = colMeans(T3);
S1 = cov(T2);
S2 = cov(T3);
spooled = function(n1, n2, S1, S2) {
return((n1 - 1) / (n1 + n2 - 2) * S1 + (n2 - 1) / (n1 + n2 - 2) * S2)
}
S_spool = spooled(n1, n2, S1, S2);S_spool
get_T2 = function(n1, n2, x_bar1, x_bar2, S1, S2) {
x_bar_diff = x_bar1 - x_bar2;
inv_S = solve((1 / n1 + 1 / n2) * spooled(n1, n2, S1, S2))
return(as.numeric(t(x_bar_diff) %*% inv_S %*% x_bar_diff))
}
get_C2 = function(n1, n2, p, alpha) {
return(((n1 + n2 - 2) * p / (n1 + n2 - p - 1) ) * qf(1 - alpha, p, n1 + n2 - p - 1))
}
get_T2(n1, n2, x_bar1, x_bar2, S1, S2)
alpha = 0.01
get_C2(n1, n2, p, alpha);
test_T2 = function(n1, n2, p, x_bar1, x_bar2, S1, S2, alpha) {
return(get_T2(n1, n2, x_bar1, x_bar2, S1, S2) > get_C2(n1, n2, p, alpha)) # Si es TRUE, se rechaza H0
}
test_T2(n1, n2, p, x_bar1, x_bar2, S1, S2, alpha)
get_T2_intervals = function(a, n1, n2, p, x_bar1, x_bar2, S1, S2, alpha) {
C = sqrt(get_C2(n1, n2, p, alpha))
left = t(a) %*% (x_bar1 - x_bar2)
right = C * sqrt(t(a) %*% ((1/n1 + 1/n2) * spooled(n1, n2, S1, S2)) %*% a)
return(matrix(c(left + right, left - right)))
}
A = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2);
alpha = 0.01
T2_intervals = matrix(0, nrow = 2, ncol = 2)
for (i in 1:nrow(A)) {
a = A[i, ]
T2_intervals[, i] = get_T2_intervals(a, n1, n2, p, x_bar1, x_bar2, S1, S2, alpha)
}
T2_intervals
z1 = matrix(c(10, 5, 7, 19, 11, 18));
z2 = matrix(c(2, 3, 3, 6, 7, 9));
y = matrix(c(15, 9, 3, 25, 7, 13));
### DATOS DE PRUEBA. Ejemplo 7.4 del libro
z1 <- matrix(c(15.31, 15.20, 16.25, 14.33, 14.57, 17.33, 14.48, 14.91, 15.25, 13.89, 15.18, 14.44, 14.87, 18.63, 15.20, 25.76, 19.05, 15.37, 18.06, 16.35))
z2 <- matrix(c(57.3, 63.8, 65.4, 57.0, 63.8, 63.2, 60.2, 57.7, 56.4, 55.6, 62.6, 63.4, 60.2, 67.2, 57.1, 89.6, 68.6, 60.1, 66.3, 65.8))
y <- matrix(c(74.8, 74.0, 72.9, 70.0, 74.9, 76.0, 72.0, 73.5, 74.5, 73.5, 71.5, 71.0, 78.9, 86.5, 68.0, 102.0, 84.0, 69.0, 88.0, 76.0))
### PUNTO A
data = data.frame(z1, z2, y)
model = lm(y ~ z1 + z2, data = data)
coefs = coef(model)
beta0 = coefs[1]
beta1 = coefs[2]
beta2 = coefs[3]
epsilon = resid(model)
coefs
epsilon
alpha = 0.05
si_beta1 = confint(model, level = 1 - alpha, parm=c(2))
si_beta2 = confint(model, level = 1 - alpha, parm=c(3))
beta1_index = 2
p_value = summary(model)$coefficients[beta1_index, 4]
alpha = 0.05
p_value > alpha # Si es FALSE, se puede rechazar H0 (que beta1 es 0)
stock data.DAT
data <- read.table("stock data.DAT", header = TRUE)
z1 = matrix(c(10, 5, 7, 19, 11, 18));
z2 = matrix(c(2, 3, 3, 6, 7, 9));
y = matrix(c(15, 9, 3, 25, 7, 13));
### DATOS DE PRUEBA. Ejemplo 7.4 del libro
z1 <- matrix(c(15.31, 15.20, 16.25, 14.33, 14.57, 17.33, 14.48, 14.91, 15.25, 13.89, 15.18, 14.44, 14.87, 18.63, 15.20, 25.76, 19.05, 15.37, 18.06, 16.35))
z2 <- matrix(c(57.3, 63.8, 65.4, 57.0, 63.8, 63.2, 60.2, 57.7, 56.4, 55.6, 62.6, 63.4, 60.2, 67.2, 57.1, 89.6, 68.6, 60.1, 66.3, 65.8))
y <- matrix(c(74.8, 74.0, 72.9, 70.0, 74.9, 76.0, 72.0, 73.5, 74.5, 73.5, 71.5, 71.0, 78.9, 86.5, 68.0, 102.0, 84.0, 69.0, 88.0, 76.0))
### PUNTO A
data = data.frame(z1, z2, y)
model = lm(y ~ z1 + z2, data = data)
coefs = coef(model)
beta0 = coefs[1]
beta1 = coefs[2]
beta2 = coefs[3]
epsilon = resid(model)
coefs
z1 = matrix(c(10, 5, 7, 19, 11, 18));
z2 = matrix(c(2, 3, 3, 6, 7, 9));
y = matrix(c(15, 9, 3, 25, 7, 13));
data = data.frame(z1, z2, y)
model = lm(y ~ z1 + z2, data = data)
coefs = coef(model); coefs
z1 = matrix(c(10, 5, 7, 19, 11, 18));
z2 = matrix(c(2, 3, 3, 6, 7, 9));
y = matrix(c(15, 9, 3, 25, 7, 13));
### DATOS DE PRUEBA. Ejemplo 7.4 del libro
z1 <- matrix(c(15.31, 15.20, 16.25, 14.33, 14.57, 17.33, 14.48, 14.91, 15.25, 13.89, 15.18, 14.44, 14.87, 18.63, 15.20, 25.76, 19.05, 15.37, 18.06, 16.35))
z2 <- matrix(c(57.3, 63.8, 65.4, 57.0, 63.8, 63.2, 60.2, 57.7, 56.4, 55.6, 62.6, 63.4, 60.2, 67.2, 57.1, 89.6, 68.6, 60.1, 66.3, 65.8))
y <- matrix(c(74.8, 74.0, 72.9, 70.0, 74.9, 76.0, 72.0, 73.5, 74.5, 73.5, 71.5, 71.0, 78.9, 86.5, 68.0, 102.0, 84.0, 69.0, 88.0, 76.0))
### PUNTO A
data = data.frame(z1, z2, y)
model = lm(y ~ z1 + z2, data = data)
coefs = coef(model); coefs
alpha = 0.05
si_beta1 = confint(model, level = 1 - alpha, parm=c(2)); si_beta1
si_beta2 = confint(model, level = 1 - alpha, parm=c(3)); si_beta2
z1 = matrix(c(10, 5, 7, 19, 11, 18));
z2 = matrix(c(2, 3, 3, 6, 7, 9));
y = matrix(c(15, 9, 3, 25, 7, 13));
data = data.frame(z1, z2, y)
model = lm(y ~ z1 + z2, data = data)
coefs = coef(model); coefs
alpha = 0.05
si_beta1 = confint(model, level = 1 - alpha, parm=c(2)); si_beta1
si_beta2 = confint(model, level = 1 - alpha, parm=c(3)); si_beta2
beta1_index = 2
p_value = summary(model)$coefficients[beta1_index, 4]
alpha = 0.05
p_value > alpha # Si es FALSE, se puede rechazar H0 (que beta1 es 0)
p_value = summary(model)$coefficients[beta1_index, 4]; p_value
beta1_index = 2
p_value = summary(model)$coefficients[beta1_index, 4]; p_value
alpha = 0.05
p_value > alpha # Si es FALSE, se puede rechazar H0 (que beta1 es 0)
newdata = data.frame(z1 = 6, z2 = 4);
expected_value2=30.96657+(2.63440*6)+(0.04518*4);
expected_value2
intervals = predict(model, newdata, interval = "confidence", level = 0.95)[2:3];
intervals
coefs[0]
coefs[1]
coefs[2]
coefs[3]
coefs[3,1]
coefs[3:1]
coefs[3]*2
newdata = data.frame(z1 = 6, z2 = 4);
expected_value2=coefs[1]+(coefs[2]*6)+(coefs[3]*4); expected_value2
intervals = predict(model, newdata, interval = "confidence", level = 0.95)[2:3]; intervals
2.147976    + (1.782316*6) - (2.188333 * 4)
pred_intervals = predict(model, newdata, interval = "prediction", level = 0.95)[2:3]
pred_intervals
summary(model)
pred_intervals = predict(model, newdata, interval = "prediction", level = 0.95)[2:3]
pred_intervals
model = lm(medv ~ lstat, data = Boston)
summary(model)
print("La pendiente es -0.95 aproximadamente")
confint(model, level = 0.95)
newdata = data.frame(lstat = c(5, 10, 15))
newdata$medv = predict(model, newdata)
newmodel = lm(medv ~ lstat, data = newdata)
confint(newmodel, level = 0.95)
knitr::opts_chunk$set(echo = TRUE)
library(MASS)
get_C = function(p) {
C = diag(1, p - 1, p) - cbind(matrix(rep(0, p - 1)), diag(1, p - 1, p - 1))
return(C)
}
T2 = function(x_bar, S, C, n) {
C_x_bar = C %*% x_bar
C_S_C_t = C %*% S %*% t(C)
return(n * (t(C_x_bar) %*% solve(C_S_C_t) %*% C_x_bar))
}
Fish = function(n, p, alpha) {
num = (n - 1) * (p - 1)
denom = (n - p + 1)
return(num / denom * qf(1 - alpha, p - 1, n - p + 1))
}
T2.test = function(x_bar, S, C, n, p, alpha) {
return (T2(x_bar, S, C, n) <= Fish(n, p, alpha))
}
p = 3;
n = 40;
x_bar = matrix(c(46.1, 57.3, 50.4))
S = matrix(c(101.3, 63, 71, 63, 80.2, 55.6, 71, 55.6, 97.4), ncol = p)
alpha = 0.05
C = get_C(p); C
T2(x_bar, S, C, n)
Fish(n, p, alpha)
T2.test(x_bar, S, C, n, p, alpha)
get_C = function(p) {
C = diag(p) - cbind(matrix(rep(0, p)), diag(1, p, p - 1));
C[p, 1] = 1
C[p, p] = -1
return (matrix(C, nrow = p, ncol = p))
}
simultaneous_ci = function(x_bar, S, C, n, p, alpha) {
left = t(C) %*% x_bar;
right = sqrt(Fish(n, p, alpha)) * sqrt((t(C) %*% S %*% C) / n)
return(c(left + right, left - right))
}
C = get_C(p)
sim_intervals = matrix(0, ncol = p, nrow = 2);
for (i in 1:p) {
c = C[i, ];
sim_intervals[, i] = simultaneous_ci(x_bar, S, c, n, p, alpha)
}
sim_intervals
n1 = 3;
n2 = 4;
p = 2;
T2 = matrix(c(3, 1, 2, 3, 6, 3), nrow = n1, ncol =p);
T3 = matrix(c(2, 5, 3, 2, 3, 1, 1, 3), nrow=n2, ncol=p);
x_bar1 = colMeans(T2);
x_bar2 = colMeans(T3);
S1 = cov(T2);
S2 = cov(T3);
spooled = function(n1, n2, S1, S2) {
return((n1 - 1) / (n1 + n2 - 2) * S1 + (n2 - 1) / (n1 + n2 - 2) * S2)
}
S_spool = spooled(n1, n2, S1, S2);S_spool
get_T2 = function(n1, n2, x_bar1, x_bar2, S1, S2) {
x_bar_diff = x_bar1 - x_bar2;
inv_S = solve((1 / n1 + 1 / n2) * spooled(n1, n2, S1, S2))
return(as.numeric(t(x_bar_diff) %*% inv_S %*% x_bar_diff))
}
get_C2 = function(n1, n2, p, alpha) {
return(((n1 + n2 - 2) * p / (n1 + n2 - p - 1) ) * qf(1 - alpha, p, n1 + n2 - p - 1))
}
get_T2(n1, n2, x_bar1, x_bar2, S1, S2)
alpha = 0.01
get_C2(n1, n2, p, alpha);
test_T2 = function(n1, n2, p, x_bar1, x_bar2, S1, S2, alpha) {
return(get_T2(n1, n2, x_bar1, x_bar2, S1, S2) > get_C2(n1, n2, p, alpha)) # Si es TRUE, se rechaza H0
}
test_T2(n1, n2, p, x_bar1, x_bar2, S1, S2, alpha)
get_T2_intervals = function(a, n1, n2, p, x_bar1, x_bar2, S1, S2, alpha) {
C = sqrt(get_C2(n1, n2, p, alpha))
left = t(a) %*% (x_bar1 - x_bar2)
right = C * sqrt(t(a) %*% ((1/n1 + 1/n2) * spooled(n1, n2, S1, S2)) %*% a)
return(matrix(c(left + right, left - right)))
}
A = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2);
alpha = 0.01
T2_intervals = matrix(0, nrow = 2, ncol = 2)
for (i in 1:nrow(A)) {
a = A[i, ]
T2_intervals[, i] = get_T2_intervals(a, n1, n2, p, x_bar1, x_bar2, S1, S2, alpha)
}
T2_intervals
z1 = matrix(c(10, 5, 7, 19, 11, 18));
z2 = matrix(c(2, 3, 3, 6, 7, 9));
y = matrix(c(15, 9, 3, 25, 7, 13));
data = data.frame(z1, z2, y)
model = lm(y ~ z1 + z2, data = data)
coefs = coef(model); coefs
alpha = 0.05
si_beta1 = confint(model, level = 1 - alpha, parm=c(2)); si_beta1
si_beta2 = confint(model, level = 1 - alpha, parm=c(3)); si_beta2
beta1_index = 2
p_value = summary(model)$coefficients[beta1_index, 4]; p_value
alpha = 0.05
p_value > alpha # Si es FALSE, se puede rechazar H0 (que beta1 es 0)
newdata = data.frame(z1 = 6, z2 = 4);
expected_value2=coefs[1]+(coefs[2]*6)+(coefs[3]*4); expected_value2
intervals = predict(model, newdata, interval = "confidence", level = 0.95)[2:3]; intervals
pred_intervals = predict(model, newdata, interval = "prediction", level = 0.95)[2:3]
pred_intervals
model = lm(medv ~ lstat, data = Boston)
summary(model)
confint(model, level = 0.95)
newdata = data.frame(lstat = c(5, 10, 15))
newdata$medv = predict(model, newdata)
newmodel = lm(medv ~ lstat, data = newdata)
confint(newmodel, level = 0.95)
plot(medv ~ lstat, data = Boston)
abline(model)
model = lm(medv ~ ., data = Boston)
confint(model, level = 0.95)
newdata = colMeans(Boston[, names(Boston) != "medv"])
newdata = data.frame(as.list(newdata))
intervals = predict(model, newdata, interval = "confidence", level = 0.95); intervals
pred_intervals = predict(model, newdata, interval = "prediction", level = 0.95); pred_intervals
n1 = 5;
n2 = 3;
n3 = 4;
p = 2;
T1 = matrix(c(2, 3, 7, 2, 7, 9, 2, 5, 1, 5), ncol = p, nrow = n1);
T2 = matrix(c(3, 2, 9, 2, 4, 4), ncol = p, nrow = n2);
T3 = matrix(c(1, 7, 4, 3, 4, 2, 9, 2), ncol = p, nrow = n3);
data = data.frame(group=rep(c("T1", "T2", "T3"), times=c(n1,n2,n3)),
x1=c(T1[,1], T2[,1], T3[,1]),
x2=c(T1[,2], T2[,2], T3[,2]))
get_B = function(model) {
return(summary(model)$SS$group)
}
get_W = function(model) {
return(summary(model)$SS$Residuals)
}
model = manova(cbind(x1,x2) ~ group,data=data)
B = get_B(model);
W = get_W(model);
oneway_manova_table = B + W; oneway_manova_table
wilks = data.frame(as.list(summary(model, test="Wilks")$stats[1,]))$Wilks;
wilks
wilks_test = function(model, alpha) {
stats = data.frame(as.list(summary(model, test="Wilks")$stats[1,]));
num_df = stats$num.Df
den_df = stats$den.Df
approx_f = stats$approx.F
f = qf(1 - alpha, num_df, den_df)
return(approx_f > f) # Si es TRUE, se rechaza H0
}
alpha = 0.05
wilks_test(model, alpha)
alpha = 0.05
g = 3
muestra = 100;
num_df = 2 * p;
den_df = 2 * (muestra - p - 2);
approx_f = (1 - sqrt(wilks)) / sqrt(wilks) * (muestra - g - 1) / (g - 1);
f = qf(1 - alpha, num_df, den_df);
print(approx_f)
print(f)
approx_f > f
model = lm(medv ~ lstat, data = Boston)
summary(model)
confint(model, level = 0.95)
newdata = data.frame(lstat = c(5, 10, 15))
newdata$medv = predict(model, newdata)
newmodel = lm(medv ~ lstat, data = newdata)
confint(newmodel, level = 0.95)
newdata
newmodel
newdata = data.frame(lstat = c(5, 10, 15))
newdata$medv = predict(model, newdata); newdata
newmodel = lm(medv ~ lstat, data = newdata)
confint(newmodel, level = 0.95)
cbind(newdata, pred)
pred <- predict(model, newdata, interval = "confidence")
pred <- predict(model, newdata, interval = "confidence")
cbind(newdata, pred)
pred <- predict(model, newdata, interval = "confidence")
newdata <- data.frame(lstat = c(5, 10, 15))
pred <- predict(model, newdata, interval = "confidence")
cbind(newdata, pred)
model = lm(medv ~ ., data = Boston)
summary(model)
confint(model, level = 0.95)
model = lm(medv ~ ., data = Boston)
confint(model, level = 0.95)
n1 = 5;
n2 = 3;
n3 = 4;
p = 2;
T1 = matrix(c(2, 3, 7, 2, 7, 9, 2, 5, 1, 5), ncol = p, nrow = n1);
T2 = matrix(c(3, 2, 9, 2, 4, 4), ncol = p, nrow = n2);
T3 = matrix(c(1, 7, 4, 3, 4, 2, 9, 2), ncol = p, nrow = n3);
data = data.frame(group=rep(c("T1", "T2", "T3"), times=c(n1,n2,n3)),
x1=c(T1[,1], T2[,1], T3[,1]),
x2=c(T1[,2], T2[,2], T3[,2]))
get_B = function(model) {
return(summary(model)$SS$group)
}
get_W = function(model) {
return(summary(model)$SS$Residuals)
}
model = manova(cbind(x1,x2) ~ group,data=data)
B = get_B(model);
W = get_W(model);
oneway_manova_table = B + W; oneway_manova_table
